schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

type Mutation {
  updateUser(user: ApplicationUserInput!): UpdatePayload!
}

type Query {
  users(where: ApplicationUserFilterInput): [ApplicationUser!]!
  user(id: String!): ApplicationUser
  roles(where: IdentityRoleFilterInput): [IdentityRole!]!
  userRoles(where: IdentityUserRoleOfStringFilterInput): [IdentityUserRoleOfString!]!
}

type Subscription {
  userAdded: ApplicationUser!
  userRoleAdded: IdentityUserRoleOfString!
}

input ApplicationUserFilterInput {
  and: [ApplicationUserFilterInput!]
  or: [ApplicationUserFilterInput!]
  firstName: StringOperationFilterInput
  lastName: StringOperationFilterInput
  profilePicture: ListComparableByteOperationFilterInput
  id: StringOperationFilterInput
  userName: StringOperationFilterInput
  normalizedUserName: StringOperationFilterInput
  email: StringOperationFilterInput
  normalizedEmail: StringOperationFilterInput
  emailConfirmed: BooleanOperationFilterInput
  passwordHash: StringOperationFilterInput
  securityStamp: StringOperationFilterInput
  concurrencyStamp: StringOperationFilterInput
  phoneNumber: StringOperationFilterInput
  phoneNumberConfirmed: BooleanOperationFilterInput
  twoFactorEnabled: BooleanOperationFilterInput
  lockoutEnd: ComparableNullableOfDateTimeOffsetOperationFilterInput
  lockoutEnabled: BooleanOperationFilterInput
  accessFailedCount: ComparableInt32OperationFilterInput
}

input IdentityRoleFilterInput {
  and: [IdentityRoleFilterInput!]
  or: [IdentityRoleFilterInput!]
  id: StringOperationFilterInput
  name: StringOperationFilterInput
  normalizedName: StringOperationFilterInput
  concurrencyStamp: StringOperationFilterInput
}

input IdentityUserRoleOfStringFilterInput {
  and: [IdentityUserRoleOfStringFilterInput!]
  or: [IdentityUserRoleOfStringFilterInput!]
  userId: StringOperationFilterInput
  roleId: StringOperationFilterInput
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input ListComparableByteOperationFilterInput {
  all: ComparableByteOperationFilterInput
  none: ComparableByteOperationFilterInput
  some: ComparableByteOperationFilterInput
  any: Boolean
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input ComparableNullableOfDateTimeOffsetOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input ComparableInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int!]
  nin: [Int!]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input ComparableByteOperationFilterInput {
  eq: Byte
  neq: Byte
  in: [Byte!]
  nin: [Byte!]
  gt: Byte
  ngt: Byte
  gte: Byte
  ngte: Byte
  lt: Byte
  nlt: Byte
  lte: Byte
  nlte: Byte
}

type ApplicationUser {
  firstName: String!
  lastName: String!
  profilePicture: [Byte!]
  id: String
  userName: String
  normalizedUserName: String
  email: String
  normalizedEmail: String
  emailConfirmed: Boolean!
  passwordHash: String
  securityStamp: String
  concurrencyStamp: String
  phoneNumber: String
  phoneNumberConfirmed: Boolean!
  twoFactorEnabled: Boolean!
  lockoutEnd: DateTime
  lockoutEnabled: Boolean!
  accessFailedCount: Int!
}

input ApplicationUserInput {
  firstName: String!
  lastName: String!
  profilePicture: [Byte!]
  id: String
  userName: String
  normalizedUserName: String
  email: String
  normalizedEmail: String
  emailConfirmed: Boolean!
  passwordHash: String
  securityStamp: String
  concurrencyStamp: String
  phoneNumber: String
  phoneNumberConfirmed: Boolean!
  twoFactorEnabled: Boolean!
  lockoutEnd: DateTime
  lockoutEnabled: Boolean!
  accessFailedCount: Int!
}

type UpdatePayload {
  success: Boolean!
}

type IdentityRole {
  id: String
  name: String
  normalizedName: String
  concurrencyStamp: String
}

type IdentityUserRoleOfString {
  userId: String
  roleId: String
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The `Byte` scalar type represents non-fractional whole numeric values. Byte can represent values between 0 and 255."
scalar Byte

directive @authorize("The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!] "Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION